---
phase: 06-deployment-gap-analysis
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/integration/test_docker_deployment_e2e.py
  - tests/integration/helpers/deployment_helpers.py
autonomous: true

must_haves:
  truths:
    - "Docker deployment creates running Velociraptor server accessible via API"
    - "Deployment rollback removes Docker container and cleans up resources"
    - "Health checks confirm server is operational before tests proceed"
  artifacts:
    - path: "tests/integration/test_docker_deployment_e2e.py"
      provides: "End-to-end Docker deployment tests"
      contains: "test_docker_deployment_lifecycle"
    - path: "tests/integration/helpers/deployment_helpers.py"
      provides: "Deployment wait and validation helpers"
      exports: ["wait_for_deployment_healthy", "verify_deployment_accessible"]
  key_links:
    - from: "tests/integration/test_docker_deployment_e2e.py"
      to: "megaraptor_mcp/deployment/deployers/docker_deployer.py"
      via: "DockerDeployer import and usage"
      pattern: "from megaraptor_mcp\\.deployment\\.deployers.*DockerDeployer"
---

<objective>
Validate Docker deployment works end-to-end with full lifecycle testing.

Purpose: DEPLOY-01 and DEPLOY-04 require proof that Docker deployments create accessible servers and rollback cleans up properly. Existing test_docker_deployment.py tests configuration but not actual deployment lifecycle.

Output: Integration tests proving Docker deployment creates working servers and rollback removes all resources.
</objective>

<execution_context>
@C:\Users\Meow\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Meow\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-deployment-gap-analysis/06-RESEARCH.md
@tests/conftest.py
@tests/integration/test_docker_deployment.py
@src/megaraptor_mcp/tools/deployment.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create deployment helper functions</name>
  <files>tests/integration/helpers/deployment_helpers.py</files>
  <action>
Create deployment_helpers.py with utilities for deployment testing:

1. `wait_for_deployment_healthy(deployer, deployment_id, timeout=120)`:
   - Poll deployer.health_check() until healthy=True or timeout
   - Use 5-second intervals
   - Raise TimeoutError with clear message on timeout
   - Return health dict on success

2. `verify_deployment_accessible(info)`:
   - Verify server_url is reachable via httpx.AsyncClient
   - Use verify=False for self-signed certs
   - Return True if status < 500, False otherwise
   - Log connection details for debugging

3. `verify_container_removed(deployer, deployment_id)`:
   - Attempt to get container via docker client
   - Return True if docker.errors.NotFound raised
   - Return False if container still exists

Follow existing helper patterns from tests/integration/helpers/.
Import docker module lazily to avoid import errors when Docker unavailable.
  </action>
  <verify>
Run: python -c "from tests.integration.helpers.deployment_helpers import wait_for_deployment_healthy, verify_deployment_accessible, verify_container_removed; print('OK')"
  </verify>
  <done>
Three helper functions exported and importable without Docker running.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker deployment E2E test suite</name>
  <files>tests/integration/test_docker_deployment_e2e.py</files>
  <action>
Create test_docker_deployment_e2e.py with comprehensive deployment lifecycle tests:

1. Test class `TestDockerDeploymentLifecycle`:
   - Use pytest markers: `@pytest.mark.integration`, `@pytest.mark.slow`
   - Use skip_no_docker decorator for all tests

2. `test_docker_deployment_lifecycle()` (DEPLOY-01):
   - Create DockerDeployer with temp_deployment_dir fixture
   - Generate test deployment config with unique ID (use uuid for isolation)
   - Generate certificates using CertificateManager (rapid profile, short validity)
   - Deploy using docker_deployer.deploy()
   - Wait for healthy using wait_for_deployment_healthy()
   - Verify accessible using verify_deployment_accessible()
   - Assert deployment result has server_url, api_url, success=True
   - Cleanup in finally block: deployer.destroy(deployment_id, force=True)

3. `test_deployment_rollback_cleanup()` (DEPLOY-04):
   - Create deployment same as above
   - Capture deployment_id and container_name
   - Verify container exists before rollback
   - Call deployer.destroy(deployment_id, force=True)
   - Verify container removed using verify_container_removed()
   - Verify deployer.get_status(deployment_id) returns None or DESTROYED state
   - Assert rollback result has success=True

4. Fixture `docker_deployer_e2e`:
   - Module-scoped fixture for DockerDeployer
   - Skip if Docker unavailable
   - Use temp directory for isolation

5. Fixture `test_certificates`:
   - Function-scoped fixture for test certificates
   - Use CertificateManager with rapid profile
   - Short validity (1 day) for test certs

Use existing patterns from test_docker_deployment.py but add actual deployment execution.
Mark tests as @pytest.mark.slow since deployments take 30-60 seconds.
  </action>
  <verify>
Run: pytest tests/integration/test_docker_deployment_e2e.py -v --collect-only
Should show: test_docker_deployment_lifecycle, test_deployment_rollback_cleanup
  </verify>
  <done>
Tests collected. DEPLOY-01 and DEPLOY-04 tests exist and can be executed when Docker available.
  </done>
</task>

<task type="auto">
  <name>Task 3: Run deployment E2E tests and verify requirements</name>
  <files>tests/integration/test_docker_deployment_e2e.py</files>
  <action>
Execute the deployment E2E tests to validate DEPLOY-01 and DEPLOY-04:

1. Run the test suite:
   pytest tests/integration/test_docker_deployment_e2e.py -v --tb=short

2. If tests pass:
   - DEPLOY-01 verified: Docker deployment creates accessible server
   - DEPLOY-04 verified: Rollback cleans up container

3. If tests fail:
   - Diagnose and fix issues in test code
   - Do NOT modify production code (deployment.py, docker_deployer.py)
   - Re-run until tests pass or skip gracefully

4. If Docker unavailable:
   - Tests should skip gracefully with clear message
   - This is acceptable - skip guards working correctly

Note: These tests create real Docker containers. Cleanup is critical.
Timeout: Tests may take 2-3 minutes for full deployment cycle.
  </action>
  <verify>
pytest tests/integration/test_docker_deployment_e2e.py -v
Expected: 2 passed OR 2 skipped (if Docker unavailable)
  </verify>
  <done>
DEPLOY-01 and DEPLOY-04 requirements validated via passing tests, or skipped gracefully if Docker unavailable.
  </done>
</task>

</tasks>

<verification>
1. `pytest tests/integration/test_docker_deployment_e2e.py -v` - tests pass or skip
2. `python -c "from tests.integration.helpers.deployment_helpers import *"` - helpers importable
3. Docker deployment creates accessible server (DEPLOY-01)
4. Deployment rollback removes container (DEPLOY-04)
</verification>

<success_criteria>
- deployment_helpers.py provides wait_for_deployment_healthy, verify_deployment_accessible, verify_container_removed
- test_docker_deployment_e2e.py tests full deployment lifecycle
- Tests pass when Docker available, skip gracefully when not
- No orphaned containers after test runs
- DEPLOY-01 and DEPLOY-04 requirements validated
</success_criteria>

<output>
After completion, create `.planning/phases/06-deployment-gap-analysis/06-01-SUMMARY.md`
</output>
