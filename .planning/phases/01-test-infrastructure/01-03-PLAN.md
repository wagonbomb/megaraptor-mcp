---
phase: 01-test-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tests/integration/helpers/target_registry.py
  - tests/integration/helpers/cert_monitor.py
  - tests/integration/helpers/__init__.py
  - tests/conftest.py
autonomous: true

must_haves:
  truths:
    - "TargetRegistry stores enrolled clients with OS type and capabilities"
    - "TargetRegistry.get_by_capability returns target matching requested capability"
    - "TargetRegistry.get_by_os returns target matching requested OS type"
    - "check_cert_expiration warns when certificate expires within 30 days"
    - "target_registry fixture waits for client enrollment before returning"
  artifacts:
    - path: "tests/integration/helpers/target_registry.py"
      provides: "Capability-based target selection"
      exports: ["TargetRegistry", "TestTarget"]
      min_lines: 60
    - path: "tests/integration/helpers/cert_monitor.py"
      provides: "Certificate expiration monitoring"
      exports: ["check_cert_expiration", "get_cert_expiry_days"]
      min_lines: 40
    - path: "tests/conftest.py"
      provides: "target_registry and cert check fixtures"
      contains: "target_registry"
  key_links:
    - from: "tests/conftest.py"
      to: "tests/integration/helpers/target_registry.py"
      via: "TargetRegistry import"
      pattern: "from tests.integration.helpers.target_registry import TargetRegistry"
    - from: "tests/conftest.py"
      to: "tests/integration/helpers/wait_helpers.py"
      via: "wait_for_client_enrollment for target discovery"
      pattern: "wait_for_client_enrollment"
---

<objective>
Create TargetRegistry for capability-based test target selection and certificate expiration monitoring to prevent infrastructure failures.

Purpose: Phase 4 will need to run OS-specific artifact tests against appropriate targets (Linux vs Windows). TargetRegistry enables this by tracking enrolled clients and their capabilities. Certificate monitoring prevents cryptic x509 errors that cause entire test suites to fail unexpectedly.

Output: target_registry.py with TargetRegistry class, cert_monitor.py with expiration checking, and fixtures in conftest.py.
</objective>

<execution_context>
@C:\Users\Meow\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\Meow\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-test-infrastructure/01-RESEARCH.md

# Dependencies from Plan 01 and 02
@tests/conftest.py
@tests/integration/helpers/wait_helpers.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TargetRegistry for capability-based target selection</name>
  <files>tests/integration/helpers/target_registry.py</files>
  <action>
Create `tests/integration/helpers/target_registry.py`:
```python
"""Target registry for capability-based test client selection.

Provides a registry of enrolled Velociraptor clients and their capabilities
to enable OS-specific and capability-specific test targeting.
"""

from dataclasses import dataclass, field
from typing import List, Optional, TYPE_CHECKING

if TYPE_CHECKING:
    from megaraptor_mcp.client import VelociraptorClient


@dataclass
class TestTarget:
    """Represents a test target client with its capabilities."""

    client_id: str
    hostname: str
    os_type: str  # "linux", "windows", "darwin"
    os_version: str = ""
    capabilities: List[str] = field(default_factory=list)
    container_name: Optional[str] = None

    def has_capability(self, capability: str) -> bool:
        """Check if target has a specific capability."""
        return capability in self.capabilities

    def is_os(self, os_type: str) -> bool:
        """Check if target matches OS type (case-insensitive)."""
        return self.os_type.lower() == os_type.lower()


class TargetRegistry:
    """Registry of available test targets with their capabilities.

    Discovers enrolled Velociraptor clients and tracks their OS type
    and supported capabilities for test targeting.

    Usage:
        registry = TargetRegistry()
        registry.discover_targets(client)

        linux_target = registry.get_by_os("linux")
        windows_target = registry.get_by_capability("windows_registry")
    """

    # Standard capabilities by OS
    LINUX_CAPABILITIES = [
        "generic_artifacts",
        "linux_filesystem",
        "linux_processes",
        "linux_users",
        "linux_network",
    ]

    WINDOWS_CAPABILITIES = [
        "generic_artifacts",
        "windows_registry",
        "windows_prefetch",
        "windows_eventlog",
        "windows_filesystem",
        "windows_processes",
    ]

    DARWIN_CAPABILITIES = [
        "generic_artifacts",
        "darwin_filesystem",
        "darwin_processes",
    ]

    def __init__(self):
        self.targets: List[TestTarget] = []

    def register_target(
        self,
        client_id: str,
        hostname: str,
        os_type: str,
        os_version: str = "",
        capabilities: Optional[List[str]] = None,
        container_name: Optional[str] = None,
    ) -> TestTarget:
        """Register a test target manually.

        Args:
            client_id: Velociraptor client ID (C.xxx)
            hostname: Client hostname
            os_type: Operating system type (linux, windows, darwin)
            os_version: OS version string
            capabilities: List of capabilities (auto-detected if None)
            container_name: Docker container name if applicable

        Returns:
            The registered TestTarget
        """
        if capabilities is None:
            capabilities = self._infer_capabilities(os_type)

        target = TestTarget(
            client_id=client_id,
            hostname=hostname,
            os_type=os_type.lower(),
            os_version=os_version,
            capabilities=capabilities,
            container_name=container_name,
        )
        self.targets.append(target)
        return target

    def discover_targets(self, client: "VelociraptorClient") -> List[TestTarget]:
        """Discover and register all enrolled clients.

        Queries Velociraptor for enrolled clients and registers them
        with auto-detected capabilities based on OS.

        Args:
            client: VelociraptorClient instance

        Returns:
            List of discovered TestTargets
        """
        discovered = []

        try:
            clients = client.query(
                "SELECT client_id, os_info, agent_information FROM clients()"
            )

            for client_data in clients:
                client_id = client_data.get("client_id")
                if not client_id:
                    continue

                os_info = client_data.get("os_info", {})
                hostname = os_info.get("hostname", os_info.get("fqdn", "unknown"))
                os_type = os_info.get("system", "linux").lower()
                os_version = os_info.get("platform_version", "")

                target = self.register_target(
                    client_id=client_id,
                    hostname=hostname,
                    os_type=os_type,
                    os_version=os_version,
                )
                discovered.append(target)

        except Exception as e:
            print(f"Target discovery warning: {e}")

        return discovered

    def get_by_capability(self, capability: str) -> Optional[TestTarget]:
        """Get first target with specified capability.

        Args:
            capability: Required capability string

        Returns:
            TestTarget with capability, or None if not found
        """
        for target in self.targets:
            if target.has_capability(capability):
                return target
        return None

    def get_by_os(self, os_type: str) -> Optional[TestTarget]:
        """Get first target with specified OS type.

        Args:
            os_type: OS type (linux, windows, darwin)

        Returns:
            TestTarget with matching OS, or None if not found
        """
        for target in self.targets:
            if target.is_os(os_type):
                return target
        return None

    def get_all_by_os(self, os_type: str) -> List[TestTarget]:
        """Get all targets with specified OS type.

        Args:
            os_type: OS type (linux, windows, darwin)

        Returns:
            List of TestTargets with matching OS
        """
        return [t for t in self.targets if t.is_os(os_type)]

    def get_all_by_capability(self, capability: str) -> List[TestTarget]:
        """Get all targets with specified capability.

        Args:
            capability: Required capability string

        Returns:
            List of TestTargets with capability
        """
        return [t for t in self.targets if t.has_capability(capability)]

    def _infer_capabilities(self, os_type: str) -> List[str]:
        """Infer capabilities based on OS type.

        Args:
            os_type: Operating system type

        Returns:
            List of inferred capabilities
        """
        os_lower = os_type.lower()
        if "linux" in os_lower:
            return self.LINUX_CAPABILITIES.copy()
        elif "windows" in os_lower:
            return self.WINDOWS_CAPABILITIES.copy()
        elif "darwin" in os_lower or "macos" in os_lower:
            return self.DARWIN_CAPABILITIES.copy()
        else:
            return ["generic_artifacts"]

    def __len__(self) -> int:
        return len(self.targets)

    def __bool__(self) -> bool:
        return len(self.targets) > 0
```
  </action>
  <verify>
Run: `python -c "from tests.integration.helpers.target_registry import TargetRegistry, TestTarget; print('OK')"`
Should print OK without import errors.
  </verify>
  <done>
target_registry.py exists with TargetRegistry and TestTarget classes.
TargetRegistry has discover_targets, get_by_capability, get_by_os methods.
TestTarget has capability and OS checking methods.
All classes are importable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create certificate expiration monitor</name>
  <files>tests/integration/helpers/cert_monitor.py</files>
  <action>
Create `tests/integration/helpers/cert_monitor.py`:
```python
"""Certificate expiration monitoring for test infrastructure.

Checks certificate expiration dates to prevent cryptic x509 errors
when test infrastructure certificates expire.
"""

import warnings
from datetime import datetime
from pathlib import Path
from typing import Optional, Tuple

# cryptography is optional - only needed for cert monitoring
try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    HAS_CRYPTOGRAPHY = True
except ImportError:
    HAS_CRYPTOGRAPHY = False


def get_cert_expiry_days(cert_pem: str) -> int:
    """Get number of days until certificate expires.

    Args:
        cert_pem: PEM-encoded certificate string

    Returns:
        Number of days until expiration (negative if already expired)

    Raises:
        ImportError: If cryptography library not installed
        ValueError: If certificate cannot be parsed
    """
    if not HAS_CRYPTOGRAPHY:
        raise ImportError(
            "cryptography library required for certificate monitoring. "
            "Install with: pip install cryptography"
        )

    try:
        cert = x509.load_pem_x509_certificate(
            cert_pem.encode(),
            default_backend()
        )
        expiry = cert.not_valid_after_utc
        now = datetime.now(expiry.tzinfo)
        delta = expiry - now
        return delta.days
    except Exception as e:
        raise ValueError(f"Failed to parse certificate: {e}")


def check_cert_expiration(
    config_path: str,
    warn_days: int = 30,
    error_days: int = 7,
) -> Tuple[bool, Optional[int], Optional[str]]:
    """Check certificate expiration from Velociraptor config file.

    Reads the certificate from a Velociraptor server or API client config
    and checks if it's close to expiration.

    Args:
        config_path: Path to Velociraptor config YAML file
        warn_days: Days before expiration to issue warning (default 30)
        error_days: Days before expiration to issue error (default 7)

    Returns:
        Tuple of (is_valid, days_remaining, message)
        - is_valid: True if certificate is valid for more than error_days
        - days_remaining: Number of days until expiration (None if check failed)
        - message: Warning or error message (None if OK)

    Note:
        Issues Python warning if certificate expires within warn_days.
    """
    if not HAS_CRYPTOGRAPHY:
        # Can't check without cryptography library
        return True, None, "Certificate check skipped (cryptography not installed)"

    config_file = Path(config_path)
    if not config_file.exists():
        return True, None, f"Config file not found: {config_path}"

    try:
        import yaml

        with open(config_file) as f:
            config = yaml.safe_load(f)

        # Try different config structures
        cert_pem = None

        # API client config format
        if "ca_certificate" in config:
            cert_pem = config.get("ca_certificate")
        # Server config format
        elif "Frontend" in config:
            cert_pem = config.get("Frontend", {}).get("certificate")
        # Client config format
        elif "Client" in config:
            cert_pem = config.get("Client", {}).get("ca_certificate")

        if not cert_pem:
            return True, None, "No certificate found in config"

        days_left = get_cert_expiry_days(cert_pem)

        if days_left < 0:
            msg = (
                f"CERTIFICATE EXPIRED {abs(days_left)} days ago! "
                f"Regenerate with: ./scripts/test-lab.sh generate-config"
            )
            return False, days_left, msg

        if days_left <= error_days:
            msg = (
                f"CERTIFICATE EXPIRES IN {days_left} DAYS! "
                f"Regenerate with: ./scripts/test-lab.sh generate-config"
            )
            return False, days_left, msg

        if days_left <= warn_days:
            msg = (
                f"Certificate expires in {days_left} days. "
                f"Consider regenerating with: ./scripts/test-lab.sh generate-config"
            )
            warnings.warn(msg, UserWarning)
            return True, days_left, msg

        return True, days_left, None

    except yaml.YAMLError as e:
        return True, None, f"Failed to parse config YAML: {e}"
    except Exception as e:
        return True, None, f"Certificate check failed: {e}"


def check_test_infrastructure_certs(
    fixtures_dir: str = "tests/fixtures",
) -> bool:
    """Check all test infrastructure certificates.

    Convenience function to check server and API client certificates.

    Args:
        fixtures_dir: Path to fixtures directory containing configs

    Returns:
        True if all certificates are valid
    """
    fixtures = Path(fixtures_dir)
    all_valid = True

    configs = [
        fixtures / "server.config.yaml",
        fixtures / "api_client.yaml",
    ]

    for config_path in configs:
        if config_path.exists():
            is_valid, days, msg = check_cert_expiration(str(config_path))
            if not is_valid:
                print(f"ERROR: {config_path.name}: {msg}")
                all_valid = False
            elif msg and days is not None:
                print(f"WARNING: {config_path.name}: {msg}")

    return all_valid
```
  </action>
  <verify>
Run: `python -c "from tests.integration.helpers.cert_monitor import check_cert_expiration; print('OK')"`
Should print OK without import errors.
Test with actual config if available.
  </verify>
  <done>
cert_monitor.py exists with check_cert_expiration, get_cert_expiry_days functions.
Functions handle missing cryptography library gracefully.
Functions handle various config file formats.
All functions are importable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add target_registry and cert check fixtures to conftest.py</name>
  <files>tests/conftest.py, tests/integration/helpers/__init__.py</files>
  <action>
Update `tests/integration/helpers/__init__.py` to include new exports:
```python
"""Integration test helpers."""
try:
    from .wait_helpers import (
        wait_for_flow_completion,
        wait_for_client_enrollment,
        wait_for_hunt_completion,
    )
    from .cleanup_helpers import (
        cleanup_test_hunts,
        cleanup_test_labels,
        cleanup_test_flows,
    )
    from .target_registry import TargetRegistry, TestTarget
    from .cert_monitor import (
        check_cert_expiration,
        get_cert_expiry_days,
        check_test_infrastructure_certs,
    )
except ImportError:
    # Modules may not exist during initial setup
    pass
```

Add fixtures to `tests/conftest.py` (at the end of the file):
```python
@pytest.fixture(scope="session")
def target_registry(docker_compose_up, velociraptor_client):
    """Provide registry of available test targets.

    Discovers enrolled clients and registers them with capabilities
    for capability-based test targeting.
    """
    if not docker_compose_up:
        pytest.skip("Docker infrastructure not available")

    try:
        from tests.integration.helpers.target_registry import TargetRegistry
        from tests.integration.helpers.wait_helpers import wait_for_client_enrollment
    except ImportError:
        pytest.skip("Test helpers not available")

    registry = TargetRegistry()

    try:
        # Wait for at least one client to enroll
        wait_for_client_enrollment(velociraptor_client, timeout=60)

        # Discover all enrolled clients
        registry.discover_targets(velociraptor_client)

    except TimeoutError:
        pytest.skip("No clients enrolled within timeout")

    if not registry:
        pytest.skip("No test targets discovered")

    return registry


@pytest.fixture(scope="session")
def enrolled_client_id(target_registry):
    """Get the first enrolled client ID.

    Convenience fixture for tests that just need any enrolled client.
    """
    if not target_registry.targets:
        pytest.skip("No enrolled clients")

    return target_registry.targets[0].client_id


@pytest.fixture(scope="session", autouse=True)
def check_certificate_expiration(velociraptor_api_config):
    """Check certificate expiration at session start.

    Issues warning if certificates expire within 30 days.
    Fails session if certificates expire within 7 days.
    """
    try:
        from tests.integration.helpers.cert_monitor import check_cert_expiration
    except ImportError:
        # Helpers not available - skip check
        yield
        return

    config_path = velociraptor_api_config.get("config_path")
    if not config_path:
        yield
        return

    is_valid, days_left, message = check_cert_expiration(config_path)

    if not is_valid:
        pytest.fail(f"Certificate check failed: {message}")

    yield

    # No cleanup needed
```

IMPORTANT: The check_certificate_expiration fixture is autouse so it runs automatically at session start. It will fail early if certificates are about to expire, giving clear error message instead of cryptic gRPC errors.
  </action>
  <verify>
Run: `pytest tests/integration/test_dfir_tools.py -v --timeout=120`
Tests should pass (or skip if Docker unavailable).
Check that certificate warning/error appears if cert expires soon.
  </verify>
  <done>
target_registry fixture exists in conftest.py (session-scoped).
enrolled_client_id convenience fixture exists.
check_certificate_expiration autouse fixture exists.
helpers/__init__.py exports all new modules.
Integration tests still pass.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Imports work:
   - `python -c "from tests.integration.helpers.target_registry import TargetRegistry; print('OK')"`
   - `python -c "from tests.integration.helpers.cert_monitor import check_cert_expiration; print('OK')"`

2. Fixtures exist in conftest.py:
   - `grep "def target_registry" tests/conftest.py` returns match
   - `grep "def enrolled_client_id" tests/conftest.py` returns match
   - `grep "def check_certificate_expiration" tests/conftest.py` returns match

3. Integration tests pass: `pytest tests/integration/test_dfir_tools.py -v --timeout=120`

4. Certificate check works (manual):
   - If cert expires soon: warning or error should appear
   - If cert OK: no message or "check skipped" if cryptography not installed
</verification>

<success_criteria>
- target_registry.py exists with TargetRegistry and TestTarget
- cert_monitor.py exists with check_cert_expiration
- conftest.py has target_registry, enrolled_client_id, check_certificate_expiration fixtures
- helpers/__init__.py exports all modules
- All new code is importable
- Integration tests pass or skip appropriately
- Certificate expiration check runs at session start
</success_criteria>

<output>
After completion, create `.planning/phases/01-test-infrastructure/01-03-SUMMARY.md`
</output>
